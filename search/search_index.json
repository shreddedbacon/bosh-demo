{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prerequisites # You need a few things installed direnv BOSH additional dependencies Using BUCC (BOSH, UAA, CredHub, and ConcourseCI) # For this intro, we will use BUCC to set up a director easily. We won't be using UAA, CredHub, or ConcourseCI in this introduction though. Clone the BUCC repository, and allow direnv to run in here git clone https://github.com/starkandwayne/bucc.git cd bucc/ direnv allow Reference Material # BOSH Terminology BOSH Guides Ultimate Guide to BOSH BOSH, UAA, CredHub, ConcourseCI Staticsite BOSH Release","title":"Getting Started"},{"location":"#prerequisites","text":"You need a few things installed direnv BOSH additional dependencies","title":"Prerequisites"},{"location":"#using_bucc_bosh_uaa_credhub_and_concourseci","text":"For this intro, we will use BUCC to set up a director easily. We won't be using UAA, CredHub, or ConcourseCI in this introduction though. Clone the BUCC repository, and allow direnv to run in here git clone https://github.com/starkandwayne/bucc.git cd bucc/ direnv allow","title":"Using BUCC (BOSH, UAA, CredHub, and ConcourseCI)"},{"location":"#reference_material","text":"BOSH Terminology BOSH Guides Ultimate Guide to BOSH BOSH, UAA, CredHub, ConcourseCI Staticsite BOSH Release","title":"Reference Material"},{"location":"deploy/","text":"Manifest # Great, we are nearly done. We need to create a deployment manifest that tells BOSH how to deploy our release. Create a manifest directory in our release, so we can keep everything there. mkdir manifests We are also going to use an existing nginx BOSH release here too, so we need to make sure the manifest knows how to set it up too. cat EOF manifests/deployment.yml --- name: static-web releases: - name: staticsite-boshrelease version: latest - name: nginx version: latest stemcells: - alias: default os: ubuntu-xenial version: latest instance_groups: - name: webserver instances: 1 stemcell: default vm_type: default azs: [ z1 ] persistent_disk_type: default networks: - name: default jobs: - name: staticsite release: staticsite-boshrelease properties: docroot: (( staticsite_docroot )) - name: nginx release: nginx properties: nginx_worker_processes: auto nginx_worker_connections: 1024 nginx_servers: - server_name: (( staticsite_domain )) docroot: (( staticsite_docroot )) port: (( staticsite_http_port )) index: index.html access_log: /var/vcap/sys/log/nginx/access.log error_log: /var/vcap/sys/log/nginx/error.log custom_data: (( nginx_config )) update: canaries: 1 max_in_flight: 1 serial: false canary_watch_time: 1000 -60000 update_watch_time: 1000 -60000 EOF Note In our manifest, you will notice that a lot of things are defined as default . This allows our manifest to be as simple as possible, and we need to make sure our cloud manifest knows how to handle defaults. We are also going to use some variables to set up the docroot, listening domain, and port for nginx. These are defined in the deployment manifest using ((variable_name)) . cat EOF manifests/variables.yml staticsite_domain: staticsite.demo staticsite_docroot: /var/vcap/store/nginx/www/document_root staticsite_http_port: 80 nginx_config: | location / { try_files $uri $uri / = 404 ; } EOF Great, we are nearly there. Stemcell # Our deployment calls for a stemcell called ubuntu-xenial. We should probably upload the stemcell into our director. bosh upload-stemcell https://bosh.io/d/stemcells/bosh-warden-boshlite-ubuntu-xenial-go_agent?v = 97 .17 #already downloaded bosh upload-stemcell ~/Downloads/bosh-stemcell-97.17-warden-boshlite-ubuntu-xenial-go_agent.tgz This can take some time, its about 400MB Nginx Release # We also told our deployment to use nginx. We should probably upload the nginx release too. bosh upload-release https://github.com/shreddedbacon/nginx-boshrelease/releases/download/v1.2.7/nginx-1.2.7.tgz Check Director # Check that our director has a stemcell associated to it bosh stemcells And also check that our 2 releases are there. bosh releases Cloud Configuration # We need to tell BOSH about our virtualbox \"cloud\" IaaS. Let's create the cloud configuration now. cat EOF virtualbox-cloud-config.yml azs: - name: z1 vm_types: - name: default disk_types: - name: default disk_size: 1024 networks: - name: default type: manual subnets: - azs: [ z1 ] dns: [ 8 .8.8.8 ] range: 10 .244.0.0/24 gateway: 10 .244.0.1 static: [ 10 .244.0.34 ] reserved: [] compilation: workers: 5 az: z1 reuse_compilation_vms: true vm_type: default network: default EOF Info The cloud configuration describes our infrastructure. You will notice we have the following default vm_type, in our manifest, our vm to build is a default type. default disk_type, in our manifest this is what our persistent_disk_type refers to * default network, in our manifest, our instance group is associated to this default network Since our director is using virtualbox and warden cpi, there isn't much else we can describe. Now update the director so it know how to use our cloud. bosh update-cloud-config virtualbox-cloud-config.yml Deploying # Now it's time to actually deploy our release. bosh --deployment = static-web deploy manifests/deployment.yml --vars-file = manifests/variables.yml or bosh -d static-web d manifests/deployment.yml -l manifests/variables.yml Check Status # Once the deployment is done, you can check the status of our VM and the services we are running on them. List Deployments # bosh deployments List VMs # bosh -d static-web vms List processes running on instances # bosh -d static-web instances --ps","title":"Deploy into VirtualBox"},{"location":"deploy/#manifest","text":"Great, we are nearly done. We need to create a deployment manifest that tells BOSH how to deploy our release. Create a manifest directory in our release, so we can keep everything there. mkdir manifests We are also going to use an existing nginx BOSH release here too, so we need to make sure the manifest knows how to set it up too. cat EOF manifests/deployment.yml --- name: static-web releases: - name: staticsite-boshrelease version: latest - name: nginx version: latest stemcells: - alias: default os: ubuntu-xenial version: latest instance_groups: - name: webserver instances: 1 stemcell: default vm_type: default azs: [ z1 ] persistent_disk_type: default networks: - name: default jobs: - name: staticsite release: staticsite-boshrelease properties: docroot: (( staticsite_docroot )) - name: nginx release: nginx properties: nginx_worker_processes: auto nginx_worker_connections: 1024 nginx_servers: - server_name: (( staticsite_domain )) docroot: (( staticsite_docroot )) port: (( staticsite_http_port )) index: index.html access_log: /var/vcap/sys/log/nginx/access.log error_log: /var/vcap/sys/log/nginx/error.log custom_data: (( nginx_config )) update: canaries: 1 max_in_flight: 1 serial: false canary_watch_time: 1000 -60000 update_watch_time: 1000 -60000 EOF Note In our manifest, you will notice that a lot of things are defined as default . This allows our manifest to be as simple as possible, and we need to make sure our cloud manifest knows how to handle defaults. We are also going to use some variables to set up the docroot, listening domain, and port for nginx. These are defined in the deployment manifest using ((variable_name)) . cat EOF manifests/variables.yml staticsite_domain: staticsite.demo staticsite_docroot: /var/vcap/store/nginx/www/document_root staticsite_http_port: 80 nginx_config: | location / { try_files $uri $uri / = 404 ; } EOF Great, we are nearly there.","title":"Manifest"},{"location":"deploy/#stemcell","text":"Our deployment calls for a stemcell called ubuntu-xenial. We should probably upload the stemcell into our director. bosh upload-stemcell https://bosh.io/d/stemcells/bosh-warden-boshlite-ubuntu-xenial-go_agent?v = 97 .17 #already downloaded bosh upload-stemcell ~/Downloads/bosh-stemcell-97.17-warden-boshlite-ubuntu-xenial-go_agent.tgz This can take some time, its about 400MB","title":"Stemcell"},{"location":"deploy/#nginx_release","text":"We also told our deployment to use nginx. We should probably upload the nginx release too. bosh upload-release https://github.com/shreddedbacon/nginx-boshrelease/releases/download/v1.2.7/nginx-1.2.7.tgz","title":"Nginx Release"},{"location":"deploy/#check_director","text":"Check that our director has a stemcell associated to it bosh stemcells And also check that our 2 releases are there. bosh releases","title":"Check Director"},{"location":"deploy/#cloud_configuration","text":"We need to tell BOSH about our virtualbox \"cloud\" IaaS. Let's create the cloud configuration now. cat EOF virtualbox-cloud-config.yml azs: - name: z1 vm_types: - name: default disk_types: - name: default disk_size: 1024 networks: - name: default type: manual subnets: - azs: [ z1 ] dns: [ 8 .8.8.8 ] range: 10 .244.0.0/24 gateway: 10 .244.0.1 static: [ 10 .244.0.34 ] reserved: [] compilation: workers: 5 az: z1 reuse_compilation_vms: true vm_type: default network: default EOF Info The cloud configuration describes our infrastructure. You will notice we have the following default vm_type, in our manifest, our vm to build is a default type. default disk_type, in our manifest this is what our persistent_disk_type refers to * default network, in our manifest, our instance group is associated to this default network Since our director is using virtualbox and warden cpi, there isn't much else we can describe. Now update the director so it know how to use our cloud. bosh update-cloud-config virtualbox-cloud-config.yml","title":"Cloud Configuration"},{"location":"deploy/#deploying","text":"Now it's time to actually deploy our release. bosh --deployment = static-web deploy manifests/deployment.yml --vars-file = manifests/variables.yml or bosh -d static-web d manifests/deployment.yml -l manifests/variables.yml","title":"Deploying"},{"location":"deploy/#check_status","text":"Once the deployment is done, you can check the status of our VM and the services we are running on them.","title":"Check Status"},{"location":"deploy/#list_deployments","text":"bosh deployments","title":"List Deployments"},{"location":"deploy/#list_vms","text":"bosh -d static-web vms","title":"List VMs"},{"location":"deploy/#list_processes_running_on_instances","text":"bosh -d static-web instances --ps","title":"List processes running on instances"},{"location":"director/","text":"Run bucc up to create a local director using virtualbox and BOSH lite This can take some time to run while it downloads resources, starts a virtual machine in virtualbox and configures it as a director. bucc up Once complete, you can get the rest of the tools if you need them (for this we aren't using them) bucc uaa bucc credhub Then run bosh env to display the director status bosh env Will produce the following output Using environment 192.168.50.6 as client admin Name bucc UUID fc8ae04d-165d-467c-9895-271dad173ec5 Version 268.0.1 (00000000) CPI warden_cpi Features compiled_package_cache: disabled config_server: enabled dns: disabled snapshots: disabled User admin And set up the host routes so your computer knows how to access the vms inside virtualbox bucc routes Note A lot of the next steps for this introduction will be run from within the bucc directory for easy clean up at the end.","title":"Build BOSH Director"},{"location":"openstack/","text":"Most of what is here is only used for this demo, some key places to look at are the following if you want to find out main differences. Deployment Manifest Operations Files Cloud Configuration Reference Information # This section is for the demo only LoadBalancer # 192.168.101.69 SSH Tunnels # A lot of the networking in this section is specific to the demo performed at the Infracoders meetup, be aware it probably won't work elsewhere. ssh -nNt -L 2222:192.168.101.91:22 10.8.0.10 #jumpbox ssh -nNt -L 7000:192.168.101.30:80 10.8.0.10 #openstack dashboard ssh -nNt -L 7001:192.168.101.69:80 10.8.0.10 #openstack loadbalancer ssh -nNt -p 2222 -L 7002:192.168.209.7:8080 ubuntu@localhost #jumpbox- director- turbulence Access # Web # Openstack Dashboard Openstack Load Balancer Pool Load Balancer Turbulence Dashboard Jumpbox # scp -p 2222 /tmp/static-site.tgz ubuntu@localhost:/tmp/static-site.tgz ssh -p ubuntu@localhost Resources # Deployment Manifest # Create the deployment manifest on the jumpbox, this is exactly the same manifest as used in virtualbox cd mkdir demo cat EOF demo/deployment.yml --- name: static-web releases: - name: staticsite-boshrelease version: latest - name: nginx version: latest stemcells: - alias: default os: ubuntu-xenial version: latest instance_groups: - name: webserver instances: 1 stemcell: default vm_type: default azs: [z1] persistent_disk_type: default networks: - name: default jobs: - name: staticsite release: staticsite-boshrelease properties: docroot: ((staticsite_docroot)) - name: nginx release: nginx properties: nginx_worker_processes: auto nginx_worker_connections: 1024 nginx_servers: - server_name: ((staticsite_domain)) docroot: ((staticsite_docroot)) port: ((staticsite_http_port)) index: index.html access_log: /var/vcap/sys/log/nginx/access.log error_log: /var/vcap/sys/log/nginx/error.log custom_data: ((nginx_config)) update: canaries: 1 max_in_flight: 1 serial: false canary_watch_time: 1000-60000 update_watch_time: 1000-60000 EOF We are also going to use some variables to set up the docroot and listening domain and port for nginx too these are defined in the deployment manifest using ((variable_name)) cat EOF demo/variables.yml staticsite_domain: staticsite.demo staticsite_docroot: /var/vcap/store/nginx/www/document_root staticsite_http_port: 80 nginx_config: | location / { try_files $uri $uri/ =404; } EOF Operations Files # We want to creat some operations that override the behaviour of our original default deployment. cat EOF demo/ops-instances.yml --- - type: replace path: /instance_groups/name=webserver/instances value: 6 - type: replace path: /instance_groups/name=webserver/vm_type value: lbmicro - type: replace path: /instance_groups/name=webserver/networks/name=default/name value: demonet01 EOF Info Our operations are only changing the vm_type and the number of instances we want to deploy, and which network they will live in. The vm_type lbmicro is defined in the Cloud Configuration. Cloud Configuration # cat EOF demo/cloud-config.yml --- azs: - name: z1 cloud_properties: availability_zone: nova vm_types: - name: default cloud_properties: instance_type: m1.micro - name: tiny cloud_properties: instance_type: m1.tiny - name: micro cloud_properties: instance_type: m1.micro - name: small cloud_properties: instance_type: m1.small - name: medium cloud_properties: instance_type: m1.medium - name: large cloud_properties: instance_type: m1.large - name: xlarge cloud_properties: instance_type: m1.xlarge - name: lbsmall cloud_properties: instance_type: m1.small loadbalancer_pools: - name: demo-pool port: 80 - name: lbmicro cloud_properties: instance_type: m1.micro loadbalancer_pools: - name: demo-pool port: 80 disk_types: - name: default disk_size: 1024 cloud_properties: type: nfs - name: micro disk_size: 5_120 cloud_properties: type: nfs - name: small disk_size: 10_240 cloud_properties: type: nfs - name: medium disk_size: 20_480 cloud_properties: type: nfs - name: large disk_size: 30_720 cloud_properties: type: nfs networks: - name: default type: manual subnets: - azs: [z1] dns: [192.168.101.1] range: 192.168.209.0/24 gateway: 192.168.209.1 static: [192.168.209.10-192.168.209.99] reserved: [192.168.209.2-192.168.209.9,192.168.209.100] cloud_properties: net_id: 16533825-c891-4e2b-8124-490a0b5bae4e security_groups: [demo-bosh, demo-web, demo-all] - name: demonet01 type: manual subnets: - azs: [z1] dns: [192.168.101.1] range: 192.168.140.0/24 gateway: 192.168.140.1 static: [192.168.140.10-192.168.140.99] reserved: [192.168.140.2-192.168.140.9,192.168.140.100] cloud_properties: net_id: ea119a90-86a0-44fc-b86c-3aa6c50dd3e0 security_groups: [demo-bosh, demo-web] - name: vip type: vip compilation: workers: 4 az: z1 reuse_compilation_vms: true vm_type: medium network: default EOF Info You can see that we have cloud_properties defined for some things in this manifest, where our virtualbox cloud configuration doesn't. Cloud properties are used to tell the CPI what to use when it builds, or what to attach something to. In the case of lbmicro we are telling it that the instance_type to use in openstack is an m1.micro, and that once built they need to be assigned to the loadbalancer pool called demo-pool . Similar things are done for the network definition where it tells the CPI which networks to build in, and which security groups to assign to vms built in those networks. Deploying # Now we are ready to deploy it into openstack. cd bucc Upload our cloud configuration bosh ucc ../demo/cloud-config.yml Upload our releases bosh upload-stemcell https://bosh.io/d/stemcells/bosh-openstack-kvm-ubuntu-xenial-go_agent?v=97.17 bosh upload-release https://github.com/shreddedbacon/nginx-boshrelease/releases/download/v1.2.7/nginx-1.2.7.tgz bosh upload-release /tmp/static-site.tgz And finally deploy it # no LB bosh -d static-web d ../demo/deployment.yml -l ../demo/variables.yml # with LB bosh -d static-web d ../demo/deployment.yml -o ../demo/ops-instances.yml -l ../demo/variables.yml","title":"Deploy into Openstack"},{"location":"openstack/#reference_information","text":"This section is for the demo only","title":"Reference Information"},{"location":"openstack/#loadbalancer","text":"192.168.101.69","title":"LoadBalancer"},{"location":"openstack/#ssh_tunnels","text":"A lot of the networking in this section is specific to the demo performed at the Infracoders meetup, be aware it probably won't work elsewhere. ssh -nNt -L 2222:192.168.101.91:22 10.8.0.10 #jumpbox ssh -nNt -L 7000:192.168.101.30:80 10.8.0.10 #openstack dashboard ssh -nNt -L 7001:192.168.101.69:80 10.8.0.10 #openstack loadbalancer ssh -nNt -p 2222 -L 7002:192.168.209.7:8080 ubuntu@localhost #jumpbox- director- turbulence","title":"SSH Tunnels"},{"location":"openstack/#access","text":"","title":"Access"},{"location":"openstack/#web","text":"Openstack Dashboard Openstack Load Balancer Pool Load Balancer Turbulence Dashboard","title":"Web"},{"location":"openstack/#jumpbox","text":"scp -p 2222 /tmp/static-site.tgz ubuntu@localhost:/tmp/static-site.tgz ssh -p ubuntu@localhost","title":"Jumpbox"},{"location":"openstack/#resources","text":"","title":"Resources"},{"location":"openstack/#deployment_manifest","text":"Create the deployment manifest on the jumpbox, this is exactly the same manifest as used in virtualbox cd mkdir demo cat EOF demo/deployment.yml --- name: static-web releases: - name: staticsite-boshrelease version: latest - name: nginx version: latest stemcells: - alias: default os: ubuntu-xenial version: latest instance_groups: - name: webserver instances: 1 stemcell: default vm_type: default azs: [z1] persistent_disk_type: default networks: - name: default jobs: - name: staticsite release: staticsite-boshrelease properties: docroot: ((staticsite_docroot)) - name: nginx release: nginx properties: nginx_worker_processes: auto nginx_worker_connections: 1024 nginx_servers: - server_name: ((staticsite_domain)) docroot: ((staticsite_docroot)) port: ((staticsite_http_port)) index: index.html access_log: /var/vcap/sys/log/nginx/access.log error_log: /var/vcap/sys/log/nginx/error.log custom_data: ((nginx_config)) update: canaries: 1 max_in_flight: 1 serial: false canary_watch_time: 1000-60000 update_watch_time: 1000-60000 EOF We are also going to use some variables to set up the docroot and listening domain and port for nginx too these are defined in the deployment manifest using ((variable_name)) cat EOF demo/variables.yml staticsite_domain: staticsite.demo staticsite_docroot: /var/vcap/store/nginx/www/document_root staticsite_http_port: 80 nginx_config: | location / { try_files $uri $uri/ =404; } EOF","title":"Deployment Manifest"},{"location":"openstack/#operations_files","text":"We want to creat some operations that override the behaviour of our original default deployment. cat EOF demo/ops-instances.yml --- - type: replace path: /instance_groups/name=webserver/instances value: 6 - type: replace path: /instance_groups/name=webserver/vm_type value: lbmicro - type: replace path: /instance_groups/name=webserver/networks/name=default/name value: demonet01 EOF Info Our operations are only changing the vm_type and the number of instances we want to deploy, and which network they will live in. The vm_type lbmicro is defined in the Cloud Configuration.","title":"Operations Files"},{"location":"openstack/#cloud_configuration","text":"cat EOF demo/cloud-config.yml --- azs: - name: z1 cloud_properties: availability_zone: nova vm_types: - name: default cloud_properties: instance_type: m1.micro - name: tiny cloud_properties: instance_type: m1.tiny - name: micro cloud_properties: instance_type: m1.micro - name: small cloud_properties: instance_type: m1.small - name: medium cloud_properties: instance_type: m1.medium - name: large cloud_properties: instance_type: m1.large - name: xlarge cloud_properties: instance_type: m1.xlarge - name: lbsmall cloud_properties: instance_type: m1.small loadbalancer_pools: - name: demo-pool port: 80 - name: lbmicro cloud_properties: instance_type: m1.micro loadbalancer_pools: - name: demo-pool port: 80 disk_types: - name: default disk_size: 1024 cloud_properties: type: nfs - name: micro disk_size: 5_120 cloud_properties: type: nfs - name: small disk_size: 10_240 cloud_properties: type: nfs - name: medium disk_size: 20_480 cloud_properties: type: nfs - name: large disk_size: 30_720 cloud_properties: type: nfs networks: - name: default type: manual subnets: - azs: [z1] dns: [192.168.101.1] range: 192.168.209.0/24 gateway: 192.168.209.1 static: [192.168.209.10-192.168.209.99] reserved: [192.168.209.2-192.168.209.9,192.168.209.100] cloud_properties: net_id: 16533825-c891-4e2b-8124-490a0b5bae4e security_groups: [demo-bosh, demo-web, demo-all] - name: demonet01 type: manual subnets: - azs: [z1] dns: [192.168.101.1] range: 192.168.140.0/24 gateway: 192.168.140.1 static: [192.168.140.10-192.168.140.99] reserved: [192.168.140.2-192.168.140.9,192.168.140.100] cloud_properties: net_id: ea119a90-86a0-44fc-b86c-3aa6c50dd3e0 security_groups: [demo-bosh, demo-web] - name: vip type: vip compilation: workers: 4 az: z1 reuse_compilation_vms: true vm_type: medium network: default EOF Info You can see that we have cloud_properties defined for some things in this manifest, where our virtualbox cloud configuration doesn't. Cloud properties are used to tell the CPI what to use when it builds, or what to attach something to. In the case of lbmicro we are telling it that the instance_type to use in openstack is an m1.micro, and that once built they need to be assigned to the loadbalancer pool called demo-pool . Similar things are done for the network definition where it tells the CPI which networks to build in, and which security groups to assign to vms built in those networks.","title":"Cloud Configuration"},{"location":"openstack/#deploying","text":"Now we are ready to deploy it into openstack. cd bucc Upload our cloud configuration bosh ucc ../demo/cloud-config.yml Upload our releases bosh upload-stemcell https://bosh.io/d/stemcells/bosh-openstack-kvm-ubuntu-xenial-go_agent?v=97.17 bosh upload-release https://github.com/shreddedbacon/nginx-boshrelease/releases/download/v1.2.7/nginx-1.2.7.tgz bosh upload-release /tmp/static-site.tgz And finally deploy it # no LB bosh -d static-web d ../demo/deployment.yml -l ../demo/variables.yml # with LB bosh -d static-web d ../demo/deployment.yml -o ../demo/ops-instances.yml -l ../demo/variables.yml","title":"Deploying"},{"location":"release/","text":"Init Release # First we need to create the release using the following command. It will create a directory called staticsite-boshrelease and will set up a few directories and files for us to help get started. bosh init-release --dir = staticsite-boshrelease This will create some directories config/ jobs/ packages/ src/ config contains files that describe our release and where our release stores its blobs externally. jobs contains all the jobs that this release will have available to it, a job is a way to run a package or packages packages contains the packages that will be used in this release, it describes how to build/compile the packages src is where you can store sourcecode and files if you don't want to utilise an external blobstore Create Source/Blob Files # Now that we have our release skeleton, we need to create the HTML that will deployed in this release, and all the resources we are using in our HTML (css/js). First we need to make a directory in the src folder to store our files that we need. mkdir src/static Now we need to get the bootstrap archive that contains the css/js we will be using and put it into the src/static directory too. wget -O src/static/bootstrap-4.1.3-dist.zip https://github.com/twbs/bootstrap/releases/download/v4.1.3/bootstrap-4.1.3-dist.zip And finally, generate the index.html file we will use. cat EOF src/static/index.html html head title Samuel L Ipsum /title link rel = stylesheet href = /css/bootstrap.min.css script src = /js/bootstrap.min.js /script /head body nav class = navbar navbar-expand-lg navbar-dark bg-dark button class = navbar-toggler type = button data-toggle = collapse data-target = #navbarSupportedContent aria-controls = navbarSupportedContent aria-expanded = false aria-label = Toggle navigation span class = navbar-toggler-icon /span /button div class = collapse navbar-collapse id = navbarSupportedContent ul class = navbar-nav mr-auto li class = nav-item active a class = nav-link href = / Home span class = sr-only ( current ) /span /a /li /ul /div /nav div class = container h1 Samuel L Ipsum /h1 !-- start slipsum code -- h2 Are you ready for the truth? /h2 Well, the way they make shows is, they make one show. That show s called a pilot. Then they show that show to the people who make shows, and on the strength of that one show they decide if they re going to make more shows. Some pilots get picked and become television programs. Some don t, become nothing. She starred in one of the ones that became nothing. h2 We happy? /h2 Now that we know who you are, I know who I am. I m not a mistake! It all makes sense! In a comic, you know how you can tell who the arch-villain s going to be? He s the exact opposite of the hero. And most times they re friends, like you and me! I should ve known way back when... You know why, David? Because of the kids. They called me Mr Glass. !-- end slipsum code -- /div /body /html EOF Generate Package # Next up we need to create the package that will copy our static site into the right location on the deployed VM. First generate the package skeleton for our package that we will call staticsite bosh generate-package staticsite Now we have a skeleton directory, it contains 2 files packages/staticsite/packaging packages/staticsite/spec Info Packaging is where we write how to compile or build our software (our static website) Spec is where we define things that our static site will need to create the package, files etc.. Lets update the spec file first, it will tell the package what we need to build with. Note BOSH will look in the src directory first for any resources, if they aren't there, it will look in the blobstore. Earlier we downloaded a zip file, and created an index.html file. We need to tell our spec file these 2 files exist, and where to find them. cat EOF packages/staticsite/spec --- name: staticsite dependencies: [] files: - static/index.html - static/bootstrap-4.1.3-dist.zip EOF Great, now we need to tell BOSH how to package these 2 things together. cat EOF packages/staticsite/packaging set -e echo Moving index.html to install target cp -a static/index.html ${ BOSH_INSTALL_TARGET } echo Extract bootsrap resources into target unzip static/bootstrap-4.1.3-dist.zip -d ${ BOSH_INSTALL_TARGET } EOF Since the bootstrap ZIP file contains our css/js, we need to unzip it into the install target directory to actually be able to use it. Note ${BOSH_INSTALL_TARGET} is a location that will be created on the deployed VM. In this case it will reference the final directory of /var/vcap/packages/staticsite/ Great, we have a script that tells BOSH how to put all our bits together. Now we need a job that knows what to do with our package. Generate Job # Now we need to create a job that will tell BOSH how to use this package. Since it is a simple static website, our job will be relatively simple. First we need to create the job structure. bosh generate-job staticsite This creates a few files jobs/staticsite/spec jobs/staticsite/monit jobs/staticsite/templates/ spec is a file that contains properties and package requirements for this job monit should know how to start/stop any services this job may have templates is a place to store templates, like start and stop scripts, drain scripts, etc. Now we have the job skeleton, we need to tell it about our package. We will need to set up a default docroot property, and tell it about a pre-start script we need. cat EOF jobs/staticsite/spec --- name: staticsite templates: pre-start.sh: bin/pre-start packages: - staticsite properties: docroot: description: Nginx docroot default: /var/vcap/store/nginx/www/document_root EOF We aren't going to use any services in this release or job, so leave the monit file blank. But we do need to tell BOSH how to set up our site on the server, for this we need a pre-start script (which has already been defined in the spec file) This contains some embedded ruby in it, which BOSH knows how to interpret. cat EOF jobs/staticsite/templates/pre-start.sh #!/bin/bash echo Create the docroot base directory mkdir -p $( dirname % = p ( docroot ) % ) echo If it our docroot already exists within it, delete it if [[ -d %= p( docroot ) % ]] then rm -rf % = p ( docroot ) % fi echo Copy our new docroot into the base directory cp -a /var/vcap/packages/staticsite % = p ( docroot ) % echo Make sure vcap owns it chown -R vcap:vcap % = p ( docroot ) % EOF Create Release # Great, we have the skeleton for a release done, now we need to create a release archive in preparation for uploading it to our director. This will create a release archive in /tmp/static-site.tgz . bosh create-release --force --tarball = /tmp/static-site.tgz Info A release archive contains EVERYTHING needed to build the release, it will contain all sourcecode for your packages and scripts. This is part of the modern release engineering principles. Now upload the release to the director bosh upload-release /tmp/static-site.tgz","title":"Create BOSH Release"},{"location":"release/#init_release","text":"First we need to create the release using the following command. It will create a directory called staticsite-boshrelease and will set up a few directories and files for us to help get started. bosh init-release --dir = staticsite-boshrelease This will create some directories config/ jobs/ packages/ src/ config contains files that describe our release and where our release stores its blobs externally. jobs contains all the jobs that this release will have available to it, a job is a way to run a package or packages packages contains the packages that will be used in this release, it describes how to build/compile the packages src is where you can store sourcecode and files if you don't want to utilise an external blobstore","title":"Init Release"},{"location":"release/#create_sourceblob_files","text":"Now that we have our release skeleton, we need to create the HTML that will deployed in this release, and all the resources we are using in our HTML (css/js). First we need to make a directory in the src folder to store our files that we need. mkdir src/static Now we need to get the bootstrap archive that contains the css/js we will be using and put it into the src/static directory too. wget -O src/static/bootstrap-4.1.3-dist.zip https://github.com/twbs/bootstrap/releases/download/v4.1.3/bootstrap-4.1.3-dist.zip And finally, generate the index.html file we will use. cat EOF src/static/index.html html head title Samuel L Ipsum /title link rel = stylesheet href = /css/bootstrap.min.css script src = /js/bootstrap.min.js /script /head body nav class = navbar navbar-expand-lg navbar-dark bg-dark button class = navbar-toggler type = button data-toggle = collapse data-target = #navbarSupportedContent aria-controls = navbarSupportedContent aria-expanded = false aria-label = Toggle navigation span class = navbar-toggler-icon /span /button div class = collapse navbar-collapse id = navbarSupportedContent ul class = navbar-nav mr-auto li class = nav-item active a class = nav-link href = / Home span class = sr-only ( current ) /span /a /li /ul /div /nav div class = container h1 Samuel L Ipsum /h1 !-- start slipsum code -- h2 Are you ready for the truth? /h2 Well, the way they make shows is, they make one show. That show s called a pilot. Then they show that show to the people who make shows, and on the strength of that one show they decide if they re going to make more shows. Some pilots get picked and become television programs. Some don t, become nothing. She starred in one of the ones that became nothing. h2 We happy? /h2 Now that we know who you are, I know who I am. I m not a mistake! It all makes sense! In a comic, you know how you can tell who the arch-villain s going to be? He s the exact opposite of the hero. And most times they re friends, like you and me! I should ve known way back when... You know why, David? Because of the kids. They called me Mr Glass. !-- end slipsum code -- /div /body /html EOF","title":"Create Source/Blob Files"},{"location":"release/#generate_package","text":"Next up we need to create the package that will copy our static site into the right location on the deployed VM. First generate the package skeleton for our package that we will call staticsite bosh generate-package staticsite Now we have a skeleton directory, it contains 2 files packages/staticsite/packaging packages/staticsite/spec Info Packaging is where we write how to compile or build our software (our static website) Spec is where we define things that our static site will need to create the package, files etc.. Lets update the spec file first, it will tell the package what we need to build with. Note BOSH will look in the src directory first for any resources, if they aren't there, it will look in the blobstore. Earlier we downloaded a zip file, and created an index.html file. We need to tell our spec file these 2 files exist, and where to find them. cat EOF packages/staticsite/spec --- name: staticsite dependencies: [] files: - static/index.html - static/bootstrap-4.1.3-dist.zip EOF Great, now we need to tell BOSH how to package these 2 things together. cat EOF packages/staticsite/packaging set -e echo Moving index.html to install target cp -a static/index.html ${ BOSH_INSTALL_TARGET } echo Extract bootsrap resources into target unzip static/bootstrap-4.1.3-dist.zip -d ${ BOSH_INSTALL_TARGET } EOF Since the bootstrap ZIP file contains our css/js, we need to unzip it into the install target directory to actually be able to use it. Note ${BOSH_INSTALL_TARGET} is a location that will be created on the deployed VM. In this case it will reference the final directory of /var/vcap/packages/staticsite/ Great, we have a script that tells BOSH how to put all our bits together. Now we need a job that knows what to do with our package.","title":"Generate Package"},{"location":"release/#generate_job","text":"Now we need to create a job that will tell BOSH how to use this package. Since it is a simple static website, our job will be relatively simple. First we need to create the job structure. bosh generate-job staticsite This creates a few files jobs/staticsite/spec jobs/staticsite/monit jobs/staticsite/templates/ spec is a file that contains properties and package requirements for this job monit should know how to start/stop any services this job may have templates is a place to store templates, like start and stop scripts, drain scripts, etc. Now we have the job skeleton, we need to tell it about our package. We will need to set up a default docroot property, and tell it about a pre-start script we need. cat EOF jobs/staticsite/spec --- name: staticsite templates: pre-start.sh: bin/pre-start packages: - staticsite properties: docroot: description: Nginx docroot default: /var/vcap/store/nginx/www/document_root EOF We aren't going to use any services in this release or job, so leave the monit file blank. But we do need to tell BOSH how to set up our site on the server, for this we need a pre-start script (which has already been defined in the spec file) This contains some embedded ruby in it, which BOSH knows how to interpret. cat EOF jobs/staticsite/templates/pre-start.sh #!/bin/bash echo Create the docroot base directory mkdir -p $( dirname % = p ( docroot ) % ) echo If it our docroot already exists within it, delete it if [[ -d %= p( docroot ) % ]] then rm -rf % = p ( docroot ) % fi echo Copy our new docroot into the base directory cp -a /var/vcap/packages/staticsite % = p ( docroot ) % echo Make sure vcap owns it chown -R vcap:vcap % = p ( docroot ) % EOF","title":"Generate Job"},{"location":"release/#create_release","text":"Great, we have the skeleton for a release done, now we need to create a release archive in preparation for uploading it to our director. This will create a release archive in /tmp/static-site.tgz . bosh create-release --force --tarball = /tmp/static-site.tgz Info A release archive contains EVERYTHING needed to build the release, it will contain all sourcecode for your packages and scripts. This is part of the modern release engineering principles. Now upload the release to the director bosh upload-release /tmp/static-site.tgz","title":"Create Release"},{"location":"turbulence/","text":"We can also run some chaos engineering if your director has been deployed with turbulence. Turbulence API Turbulence API Docs Note By default BUCC does not build with turbulence cp src/bosh-deployment/turbulence.yml ops/9-turbulence.yml export TURBULENCE_PASSWORD = $ ( bosh int state / creds . yml -- path / turbulence_api_password ) cat EOF kill . sh set - e body = { Tasks : [{ Type : Kill }], Selector : { Deployment : { Name : static-web }, Group : { Name : webserver }, ID : { Limit : 10%-60% } } } echo $ body | curl - vvv - k - X POST https : //turbulence:${TURBULENCE_PASSWORD}@192.168.209.7:8080/api/v1/incidents -H Accept: application/json -d @- echo EOF chmod + x kill . sh Run it ./kill.sh Checking in the Openstack console, you will see that one or more vms will be gone. After about a minute or so, BOSH will see this machine missing and start the process of rebuilding it. You can also schedule instances to be destroyed, and a bunch of other chaos engineering tasks, like full disk, high cpu, high memory etc..","title":"Chaos Engineering"}]}